<!DOCTYPE html>
<!-- saved from url=(0065)https://cutsceneartist.com/DrawThings/StoryflowEditor_online.html -->
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <title>Storyflow Editor for DrawThings</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="StoryFlow" />
    <link
      rel="apple-touch-icon"
      href="https://cutsceneartist.com/DrawThings/app-icon.png"
    />
    <style>
      .app-header-container {
        display: flex;
        justify-content: space-between; /* Pushes the title group to the left and buttons to the right */
        //align-items: center; /* Vertically centers items */
        padding: 15px 20px;
        font-family: sans-serif; /* Clean, app-like font */
      }

      /* Grouping the Title and Version Info */
      .app-header-title {
        display: flex;
        align-items: baseline;
        gap: 15px; /* Space between title and version */
      }

      .app-header-title h1 {
        font-size: 20px;
        font-weight: 600;
        color: #333;
        margin: 0;
      }

      .app-version {
        font-size: 8px;
        color: #888;
        font-weight: 400;
      }

      /* Navigation Group: Adds spacing between all buttons 
*/
      .app-header-nav {
        display: flex;
        gap: 10px;
      }

      /* Base Button Style (Applies to all links with class="app-button") */
      .app-button {
        text-decoration: none; /* Remove underline */
        padding: 2px 4px;
        border-radius: 4px; /* Slightly rounded corners */
        font-size: 10px;
        font-weight: 200;
        transition: background-color 0.2s, opacity 0.2s; /* Smooth hover effect */
      }

      /* Primary Action Button (for the main download) 
  Uses a prominent color to stand out.
*/
      .primary-action {
        background-color: #007bff; /* A standard blue for primary actions */
        color: white;
        border: 0px solid #007bff;
      }

      .primary-action:hover {
        background-color: #0056b3;
      }

      /* Secondary Action Button (for tutorial/config) 
  Less prominent, using a border/outline style.
*/
      .secondary-action {
        background-color: transparent;
        color: #007bff;
        border: 0px solid #007bff;
      }

      .secondary-action:hover {
        background-color: #e9f5ff; /* Light blue background on hover */
      }
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        font-size: 120%;
        zoom: 1.2;
      }
      h2 {
        margin-top: 30px;
      }
      .section {
        margin-bottom: 20px;
      }
      /* === IMPORTANT FIX: Added .wildcard-shortcut and .poseJSON-shortcut === */
      .trigger,
      .config-shortcut,
      .wildcard-shortcut,
      .poseJSON-shortcut,
      .item {
        display: flex;
        align-items: center;
        margin: 6px 0;
      }
      /* == Flex/Layout Rules for Inputs == */
      /* Inputs in main item list */
      .item input[type="text"],
      .item textarea {
        margin-right: 8px;
        flex: 1;
      }
      /* Inputs in tabbed 'trigger' section */
      .trigger input {
        margin-right: 8px;
        flex: 1; /* 1 part space */
      }
      .trigger textarea {
        margin-right: 8px;
        flex: 3; /* 3 parts space */
      }
      /* Inputs in tabbed 'config-shortcut' section */
      .config-shortcut input {
        margin-right: 8px;
        flex: 1; /* 1 part space */
      }
      .config-shortcut textarea {
        margin-right: 8px;
        flex: 3; /* 3 parts space */
      }
      /* === NEW: Rules for Wildcard and JSON Pose tabs === */
      .wildcard-shortcut input,
      .poseJSON-shortcut input {
        margin-right: 8px;
        flex: 1; /* 1 part space */
      }
      .wildcard-shortcut textarea,
      .poseJSON-shortcut textarea {
        margin-right: 8px;
        flex: 3; /* 3 parts space */
      }
      /* == Height/Resize Rules for TextAreas == */
      /* Apply to all textareas in tabs and main list (UPDATED) */
      .trigger textarea,
        .config-shortcut textarea,
        .wildcard-shortcut textarea, /* Added */
        .poseJSON-shortcut textarea,  /* Added */
        .item textarea {
        min-height: 48px;
        resize: vertical;
      }
      button {
        margin-left: 6px;
        border-radius: 5px;
        border: 1px solid #8f8f9d;
      }
      .btn {
        border-radius: 3px;
        background-color: #e9e9ed;
        cursor: pointer;
        border: 1px solid #8f8f9d;
        border-radius: 5px;
        padding: 2px 5px;
      }
      .btn:hover {
        background-color: #d0d0d7;
      }
      .btn-project {
        background-color: #e9e9ed;
        border-radius: 3px;
        border: 1px solid #8f8f9d;
        padding: 4px 5px;
      }
      .btn-project:hover {
        background-color: #d0d0d7;
      }
      .btn-saveProject {
        background-color: #e9e9ed;
        border-radius: 3px;
        border: 1px solid #cc0000;
        padding: 4px 5px;
      }
      .btn-saveProject:hover {
        background-color: #edd7d8;
      }
      .btn-special {
        background-color: #e9e9ed;
        border-radius: 4px;
        border: 1px solid #0000cc;
        padding: 2px 5px;
      }
      .btn-special:hover {
        background-color: #cad6e6;
      }
      .btn-xlMagic {
        background-color: #5a8fba;
        color: #ffe739;
        border-radius: 5px;
        border: 1px solid #d4a754;
        padding: 0px 5px;
      }
      .btn-xlMagic:hover {
        background-color: #3d80d9;
        color: #e9d862;
        border-color: #ffe03a;
      }
      .btn-note {
        background-color: #faf6dc;
        color: #212529;
        padding: 2px 5px;
      }
      .btn-note:hover {
        background-color: #f9edb0;
      }
      .btn-prompt {
        background-color: #fae2e9;
        color: #212529;
        padding: 2px 5px;
      }
      .btn-prompt:hover {
        background-color: #fac2c2;
      }
      .btn-config {
        background-color: #d8f0e0;
        color: #212529;
        padding: 2px 5px;
      }
      .btn-config:hover {
        background-color: #b2f8c7;
      }
      .btn-frames {
        background-color: #cddef0;
        color: #212529;
        padding: 2px 5px;
      }
      .btn-frames:hover {
        background-color: #91c0ff;
      }
      .btn-moodboard {
        background-color: #eee2fa;
        color: #212529;
        padding: 2px 5px;
      }
      .btn-moodboard:hover {
        background-color: #e7d2f7;
      }
      .btn-mask {
        background-color: #e9e9ed;
        padding: 0px 5px;
      }
      .btn-mask:hover {
        background-color: #d0d0d7;
      }
      .btn-canvas {
        background-color: #e9e9ed;
        padding: 0px 5px;
      }
      .btn-canvas:hover {
        background-color: #d0d0d7;
      }
      .btn-depth {
        background-color: #d1d1d9;
        padding: 2px 5px;
      }
      .btn-depth:hover {
        background-color: #bdbdcf;
      }
      .btn-loop {
        background-color: #f2d7cd;
        color: #212529;
        padding: 2px 5px;
      }
      .btn-loop:hover {
        background-color: #f5ccb0;
      }
      #promptList {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .item {
        background: #f9f9f9;
        border: 1px solid;
        border-color: #cccccc;
        border-radius: 6px;
        padding: 6px;
      }
      .item[data-type="note"] {
        background: #faf6dc;
      }
      .item[data-type="prompt"] {
        background: #fae2e9;
      }
      .item[data-type="config"] {
        background: #d8f0e0;
      }
      .item[data-type="frames"] {
        background: #cddef0;
      }
      .item[data-type^="moodboard"] {
        background: #eee2fa;
      }
      .item[data-type^="depth"] {
        background: #d1d1d9;
      }
      .item[data-type="xlMagic"] {
        color: #ffe739;
        background: #5a8fba;
        border-color: #ffe03a;
      }
      .item[data-type^="loop"] {
        background: #f2d7cd;
      }
      .drag-handle {
        cursor: grab;
        padding: 4px 8px;
        margin-right: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        user-select: none;
      }
      .drag-handle:active {
        cursor: grabbing;
        background: #ccc;
      }
      #preview {
        white-space: pre-wrap;
        border: 1px solid #ddd;
        padding: 10px;
        background: #fafafa;
      }
      .drop-indicator {
        height: 6px;
        background: #4a90e2;
        margin: 2px 0;
        border-radius: 3px;
        pointer-events: none;
      }
      .item.dragging {
        opacity: 0.5;
      }
      .item-type-label {
        font-weight: 600;
        margin-right: 8px;
        min-width: 90px;
        text-transform: capitalize;
      }
      .small-muted {
        font-size: 12px;
        color: #666;
        margin-left: 8px;
      }
      .controls-row {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 8px;
      }
      .add-buttons {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        column-gap: 6px;
        row-gap: 4px;
      }
      /* Tab Container Styles */
      .tab-nav {
        display: flex;
        gap: 4px;
        margin-left: 10px; /* Indent tabs slightly */
        margin-bottom: -1px; /* Overlaps with content border */
      }
      .tab-button {
        padding: 8px 16px;
        cursor: pointer;
        border: 1px solid #ccc;
        border-bottom: none;
        background-color: #f1f1f1;
        border-radius: 6px 6px 0 0;
        font-weight: 500;
        color: #333;
      }
      .tab-button:hover {
        background-color: #e9e9e9;
      }
      .tab-button.active {
        background-color: #fdfdfd; /* Match content background */
        border-bottom: 1px solid #fdfdfd; /* Hides bottom border */
        font-weight: 600;
        color: #000;
        position: relative;
      }
      .tab-content {
        border: 1px solid #ccc;
        border-radius: 8px; /* Apply to all corners */
        background: #fdfdfd;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        /* list-container and footer inside will provide padding */
      }
      .tab-panel {
        display: none; /* Hidden by default */
      }
      .tab-panel.active {
        display: block; /* Shown when active */
      }
      /* End Tab Styles */
      .button-row {
        display: flex;
        gap: 10px;
        margin-bottom: 10px; /* Adds space between rows */
      }
      .force-break {
        flex-basis: 100%;
        height: 0;
      }
      .slider-row {
        display: flex;
        gap: 10px;
        align-items: center;
        width: 100%;
      }
      .value-badge {
        min-width: 34px;
        text-align: center;
        font-weight: 700;
        padding: 4px 6px;
        border-radius: 4px;
        background: #fff;
        border: 1px solid #ddd;
      }
      .list-container {
        flex: 1;
        padding: 10px;
        overflow-y: auto;
        max-height: 300px;
      }
      .column .footer {
        padding: 10px;
        border-top: 1px solid #ddd;
        background: #fafafa;
      }
      .autocomplete-suggestions,
      #wildcard-suggestions {
        position: fixed;
        top: 15%;
        left: 50%;
        transform: translateX(-50%);
        border: 1px solid #ccc;
        background-color: white;
        z-index: 9999;
        max-height: 150px;
        min-width: 200px;
        max-width: 300px;
        overflow-y: auto;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        border-radius: 4px;
        font-size: 14px;
      }
      .autocomplete-suggestions div,
      #wildcard-suggestions div {
        padding: 6px 10px;
        cursor: pointer;
        white-space: nowrap;
      }
      .autocomplete-suggestions div:hover,
      #wildcard-suggestions div:hover {
        background-color: #f2f2f2;
      }
      .item-index {
        font-weight: 600;
        color: #888;
        width: 24px;
        text-align: right;
        margin-right: 8px;
        flex-shrink: 0;
        font-size: 14px;
      }
      /* New Sticky Footer Styles */
      #fixed-instructions-bar {
        position: fixed; /* Lock it to the viewport */
        bottom: 0; /* Place it at the bottom */
        left: 0;
        right: 0;
        padding: 8px 20px 10px 20px; /* Adjust padding for visual appeal */
        background-color: #f0f0f5; /* Light grey background */
        border-top: 2px solid #ccc; /* Separator line */
        z-index: 1000; /* Ensure it stays on top of other content */
        box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.05); /* Optional subtle shadow */
      }

      /* Ensure content above doesn't get hidden behind the footer */
      body {
        padding-bottom: 180px; /* Adjust this value to be taller than your sticky bar */
      }

      #fixed-instructions-bar h3 {
        margin: 0 0 5px 0;
        font-size: 14px;
        font-weight: 500;
      }

      /* IMPORTANT: Only disable pointer events during a drag operation */
      /* This requires setting a class on the body or list when dragging is active */
      #promptList.dragging-active .item input,
      #promptList.dragging-active .item textarea,
      #promptList.dragging-active .item button,
      #promptList.dragging-active .item select {
        pointer-events: none;
      }
    </style>
    <style>
      .imageye-selected {
        outline: 2px solid black !important;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5) !important;
      }
    </style>
  </head>

  <body
    cz-shortcut-listen="true"
    style="max-width: 100%; transition: max-width 0.5s ease-in-out"
  >
    <header class="app-header-container">
      <div class="app-header-title">
        <h1>Storyflow Editor</h1>
        <span class="app-version">251126</span>
      </div>

      <nav class="app-header-nav">
        <a
          href="https://cutsceneartist.com/DrawThings/StoryflowPipeline.zip"
          class="app-button secondary-action"
          >Pipeline Plugin for DrawThings</a
        >

        <a
          href="https://youtu.be/QraK3gKtAJA"
          class="app-button secondary-action"
          >Video Tutorial</a
        >

        <a
          href="https://cutsceneartist.com/DrawThings/GetConfigPro.zip"
          class="app-button secondary-action"
          >Get Config Pro</a
        >
      </nav>
    </header>

    <div class="tab-container section">
      <div class="tab-nav">
        <button
          id="defaultOpen"
          class="tab-button"
          onclick="openTab(event, &#39;tab-triggers&#39;)"
        >
          Prompt Triggers
        </button>
        <button
          class="tab-button"
          onclick="openTab(event, &#39;tab-shortcuts&#39;)"
        >
          Config Shortcuts
        </button>
        <button
          class="tab-button"
          onclick="openTab(event, &#39;tab-wildcards&#39;)"
        >
          Wildcards
        </button>
        <button
          class="tab-button"
          onclick="openTab(event, &#39;tab-poses&#39;)"
        >
          JSON Poses
        </button>
      </div>

      <div class="tab-content">
        <div id="tab-triggers" class="tab-panel">
          <div class="list-container" id="triggerListPrompt"></div>
          <div class="footer">
            <button class="btn" onclick="addTriggerPrompt()">
              + Add Prompt Trigger
            </button>
            <p class="small-muted">
              User-defined triggerwords used by the
              <strong>prompt</strong> items only
            </p>
          </div>
        </div>

        <div id="tab-shortcuts" class="tab-panel">
          <div class="list-container" id="configShortcutsList"></div>
          <div class="footer">
            <button class="btn" onclick="addConfigShortcut()">
              + Add Config Shortcut
            </button>
            <div style="margin-top: 10px; border-top: 1px solid #444; padding-top: 10px;">
                <button class="btn" style="background-color: #2a3b4c; color: #fff; text-shadow: none; border: 1px solid #3e566d;" onclick="importConfigPoseScript()">
                  Load Configs/Poses
                </button>
                <button class="btn" style="background-color: #2a3b4c; color: #fff; text-shadow: none; border: 1px solid #3e566d;" onclick="exportConfigPoseScript()">
                  Save Configs/Poses
                </button>
            </div>
            <p class="small-muted">
              User-defined shortcuts used by the <strong>config</strong> items
              only
            </p>
          </div>
        </div>

        <div id="tab-wildcards" class="tab-panel">
          <div class="list-container" id="wildcardsList"></div>
          <div class="footer">
            <button class="btn" onclick="addWildcard()">+ Add Wildcard</button>
            <p class="small-muted">Define wildcards for prompt items</p>
          </div>
        </div>

        <div id="tab-poses" class="tab-panel">
          <div class="list-container" id="poseJSONShortcutsList"></div>
          <div class="footer">
            <button class="btn" onclick="addPose()">+ Add Pose Shortcut</button>
            <p class="small-muted">Define shortcuts for JSON poses</p>
          </div>
        </div>
      </div>
    </div>

    <div id="promptList" aria-live="polite">
      <div
        class="item"
        draggable="false"
        data-type="prompt"
        data-value-type="string"
        data-index="1"
      >
        <div class="drag-handle" draggable="true">‚ãÆ‚ãÆ</div>
        <span class="item-index">1.</span>
        <div class="item-type-label">prompt</div>
        <textarea
          placeholder="Prompt will generate 
Add triggers and wildcards: @hero at $location 
Do not use quotes they will break Pipeline instructions"
        ></textarea
        ><button title="Remove item">‚ùå</button>
      </div>
    </div>

    <div id="fixed-instructions-bar">
      <div class="controls-row">
        <div class="add-buttons">
          <button
            class="btn-note"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;note&#39;)"
            onclick="addItem(&#39;note&#39;)"
          >
            + Note
          </button>
          <button
            class="btn-prompt"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;prompt&#39;)"
            onclick="addItem(&#39;prompt&#39;)"
          >
            + Prompt
          </button>
          <button
            class="btn-config"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;config&#39;)"
            onclick="addItem(&#39;config&#39;)"
          >
            + Config
          </button>
          <button
            class="btn-frames"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;frames&#39;)"
            onclick="addItem(&#39;frames&#39;)"
          >
            + Frames
          </button>
          <button
            class="btn-special"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;faceZoom&#39;)"
            onclick="addItem(&#39;faceZoom&#39;)"
          >
            + FaceZoom
          </button>
          <button
            class="btn-special"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;askZoom&#39;)"
            onclick="addItem(&#39;askZoom&#39;)"
          >
            + AskZoom
          </button>
          <button
            class="btn-special"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;removeBkgd&#39;)"
            onclick="addItem(&#39;removeBkgd&#39;)"
          >
            + Remove Bkgd
          </button>
          <div class="force-break"></div>
          <button
            class="btn-canvas"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;canvasClear&#39;)"
            onclick="addItem(&#39;canvasClear&#39;)"
          >
            + Clear Canvas
          </button>
          <button
            class="btn-canvas"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;canvasSave&#39;)"
            onclick="addItem(&#39;canvasSave&#39;)"
          >
            + Save Canvas
          </button>
          <button
            class="btn-canvas"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;canvasLoad&#39;)"
            onclick="addItem(&#39;canvasLoad&#39;)"
          >
            + Load Canvas
          </button>
          <button
            class="btn-special"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;moveScale&#39;)"
            onclick="addItem(&#39;moveScale&#39;)"
          >
            + Move Scale
          </button>
          <button
            class="btn-special"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;adaptSize&#39;)"
            onclick="addItem(&#39;adaptSize&#39;)"
          >
            + Adapt Size
          </button>
          <button
            class="btn-special"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;crop&#39;)"
            onclick="addItem(&#39;crop&#39;)"
          >
            + Crop
          </button>
          <div class="force-break"></div>
          <button
            class="btn-moodboard"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;moodboardClear&#39;)"
            onclick="addItem(&#39;moodboardClear&#39;)"
          >
            + Clear Moodboard
          </button>
          <button
            class="btn-moodboard"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;moodboardCanvas&#39;)"
            onclick="addItem(&#39;moodboardCanvas&#39;)"
          >
            + Canvas to MB
          </button>
          <button
            class="btn-moodboard"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;moodboardAdd&#39;)"
            onclick="addItem(&#39;moodboardAdd&#39;)"
          >
            + Add MB
          </button>
          <button
            class="btn-moodboard"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;moodboardRemove&#39;)"
            onclick="addItem(&#39;moodboardRemove&#39;)"
          >
            + Remove
          </button>
          <button
            class="btn-moodboard"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;moodboardWeights&#39;)"
            onclick="addItem(&#39;moodboardWeights&#39;)"
          >
            + Weights
          </button>
          <button
            class="btn-loop"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;loopAddMB&#39;)"
            onclick="addItem(&#39;loopAddMB&#39;)"
          >
            + Add‚í§ MB
          </button>
          <div class="force-break"></div>
          <button
            class="btn"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;maskClear&#39;)"
            onclick="addItem(&#39;maskClear&#39;)"
          >
            + Clear Mask
          </button>
          <button
            class="btn"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;maskLoad&#39;)"
            onclick="addItem(&#39;maskLoad&#39;)"
          >
            + Load Mask
          </button>
          <button
            class="btn-mask"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;maskGet&#39;)"
            onclick="addItem(&#39;maskGet&#39;)"
          >
            + Get üë§
          </button>
          <button
            class="btn-mask"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;maskBkgd&#39;)"
            onclick="addItem(&#39;maskBkgd&#39;)"
          >
            + Bkgd üë§
          </button>
          <button
            class="btn-mask"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;maskFG&#39;)"
            onclick="addItem(&#39;maskFG&#39;)"
          >
            + FG üë§
          </button>
          <button
            class="btn-mask"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;maskBody&#39;)"
            onclick="addItem(&#39;maskBody&#39;)"
          >
            + Body üë§
          </button>
          <button
            class="btn-mask"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;maskAsk&#39;)"
            onclick="addItem(&#39;maskAsk&#39;)"
          >
            + Ask üë§
          </button>
          <div class="force-break"></div>
          <button
            class="btn-depth"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;depthExtract&#39;)"
            onclick="addItem(&#39;depthExtract&#39;)"
          >
            + Extract Depth
          </button>
          <button
            class="btn-depth"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;depthCanvas&#39;)"
            onclick="addItem(&#39;depthCanvas&#39;)"
          >
            + Canvas to Depth
          </button>
          <button
            class="btn-depth"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;depthToCanvas&#39;)"
            onclick="addItem(&#39;depthToCanvas&#39;)"
          >
            + Depth to Canvas
          </button>
          <button
            class="btn-mask"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;inpaintTools&#39;)"
            onclick="addItem(&#39;inpaintTools&#39;)"
          >
            + Inpaint Tools
          </button>
          <button
            class="btn-xlMagic"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;xlMagic&#39;)"
            onclick="addItem(&#39;xlMagic&#39;)"
          >
            + XL Magic‚ú®
          </button>
          <div class="force-break"></div>
          <button
            class="btn"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;negPrompt&#39;)"
            onclick="addItem(&#39;negPrompt&#39;)"
          >
            + Neg Prompt
          </button>
          <button
            class="btn"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;poseJSON&#39;)"
            onclick="addItem(&#39;poseJSON&#39;)"
          >
            + JSON Pose
          </button>
          <button
            class="btn"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;fileLoad&#39;)"
            onclick="addItem(&#39;fileLoad&#39;)"
          >
            + Pipeline
          </button>
          <button
            class="btn-loop"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;loop&#39;)"
            onclick="addItem(&#39;loop&#39;)"
          >
            + Loop
          </button>
          <button
            class="btn-loop"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;loopSave&#39;)"
            onclick="addItem(&#39;loopSave&#39;)"
          >
            + Save ‚í§
          </button>
          <button
            class="btn-loop"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;loopLoad&#39;)"
            onclick="addItem(&#39;loopLoad&#39;)"
          >
            + Load ‚í§
          </button>
          <button
            class="btn-loop"
            draggable="true"
            ondragstart="handleNewItemDragStart(event, &#39;loopEnd&#39;)"
            onclick="addItem(&#39;loopEnd&#39;)"
          >
            + EndLoop
          </button>
        </div>
      </div>
    </div>

    <div class="section">
      <h3>Project</h3>
      <div class="section">
        <label
          >Name:
          <input
            type="text"
            id="projectName"
            placeholder="Enter project name"
            oninput="updatePreview()"
          />
        </label>
      </div>
      <button class="btn-project" onclick="newProject()">üÜï New Project</button>
      <button class="btn-saveProject" onclick="saveProject()">
        üíæ Save Project
      </button>
      <button class="btn-project" onclick="loadProject()">
        üìÇ Load Project
      </button>
      <button class="btn-project" onclick="exportTextfile()">
        ‚¨áÔ∏è Export to Pipeline
      </button>
      <button class="btn-project" onclick="importWildcardScript()">
        üìÇ Import Wildcard Script
      </button>
      <button class="btn-project" onclick="exportWildcardScript()">
        ‚¨áÔ∏è Export Wildcard Script
      </button>
      <button class="btn-project" onclick="exportClipboard()">
        üìã Export to Clipboard
      </button>
    </div>

    <div class="section">
      <div id="previewContainer">
        <h3>
          Preview
          <button
            id="previewToggle"
            class="btn-project"
            onclick="togglePreview()"
          >
            Hide
          </button>
        </h3>
        <pre id="preview">
=== PROJECT: Unnamed ===

Prompt Total: 1
Frames Total: 0 (0.00 sec 16fps)

=== Instructions (expanded prompts) ===
[1] prompt: ""

</pre
        >
      </div>
    </div>

    <script>
      /* ===========================
           State
           =========================== */
      let promptTriggers = {};
      let configShortcuts = {};
      let poseJSONShortcuts = {};
      let wildcardShortcuts = {};
      const dropIndicator = document.createElement("div");
      dropIndicator.className = "drop-indicator";
      let draggedEl = null;
      let suggestionsEl = null;

      /* ===========================
           Utility helpers
           =========================== */
      function formatTypeLabel(type) {
        const map = {
          note: "note",
          prompt: "prompt",
          config: "config",
          frames: "frames",
          negPrompt: "neg prompt",
          faceZoom: "face zoom",
          askZoom: "ask zoom",
          removeBkgd: "remove background",
          canvasClear: "clear canvas",
          canvasSave: "save canvas",
          canvasLoad: "load canvas",
          moveScale: "move & scale",
          adaptSize: "adapt size to fit image",
          crop: "crop",
          moodboardClear: "clear moodboard",
          moodboardAdd: "add to moodboard",
          moodboardLoad: "add to moodboard",
          moodboardCanvas: "canvas to moodboard",
          moodboardRemove: "remove moodboard",
          moodboardWeights: "set moodboard weights",
          loopAddMB: "Add‚í§ to moodboard",
          maskClear: "clear mask",
          maskLoad: "load mask",
          maskGet: "get mask",
          maskBkgd: "mask background",
          maskFG: "mask foreground",
          maskBody: "mask body",
          maskAsk: "ask mask",
          inpaintTools: "in-paint tools",
          depthExtract: "extract depthmap",
          depthCanvas: "canvas to depth layer",
          depthToCanvas: "depth layer to canvas",
          xlMagic: "XL magic‚ú®",
          poseClear: "clear pose",
          poseJSON: "JSON pose",
          fileLoad: "add pipeline",
          loop: "loop",
          loopLoad: "load image‚í§ from",
          loopSave: "save image‚í§",
          loopEnd: "endLoop",
        };
        return map[type] || type;
      }

      /* ===========================
           Prompt triggers (Prompt-only)
           =========================== */
      function addTriggerPrompt(key = "", value = "", skipUpdate = false) {
        const container = document.createElement("div");
        container.className = "trigger";
        const keyInput = document.createElement("input");
        keyInput.placeholder = "trigger (e.g. @hero)";
        keyInput.value = key;
        keyInput.oninput = () => {
          savePromptTriggers();
          updatePreview();
        };
        const valueInput = document.createElement("textarea");
        valueInput.placeholder = "value (e.g. brave knight)";
        valueInput.value = value;
        valueInput.oninput = () => {
          savePromptTriggers();
          updatePreview();
        };
        const delBtn = document.createElement("button");
        delBtn.textContent = "‚ùå";
        delBtn.onclick = () => {
          container.remove();
          savePromptTriggers();
          updatePreview();
        };
        container.appendChild(keyInput);
        container.appendChild(valueInput);
        container.appendChild(delBtn);
        document.getElementById("triggerListPrompt").appendChild(container);
        savePromptTriggers();
        if (!skipUpdate) updatePreview();
      }

      function savePromptTriggers() {
        promptTriggers = {};
        document
          .querySelectorAll("#triggerListPrompt .trigger")
          .forEach((t) => {
            const key = t.children[0].value.trim();
            const val = t.children[1].value.trim();
            if (key) promptTriggers[key] = val;
          });
      }

      /* ===========================
           Config Shortcuts (Config-only)
           =========================== */
      function addConfigShortcut(key = "", value = "", skipUpdate = false) {
        const container = document.createElement("div");
        container.className = "config-shortcut";
        const keyInput = document.createElement("input");
        keyInput.placeholder = "shortcut (e.g. #Wan_i2v)";
        keyInput.value = key;
        keyInput.oninput = () => {
          saveConfigShortcuts();
          updatePreview();
        };
        const valInput = document.createElement("textarea");
        valInput.placeholder = "paste a full or parameter config {...}";
        valInput.value = value;
        valInput.oninput = () => {
          saveConfigShortcuts();
          updatePreview();
        };
        const delBtn = document.createElement("button");
        delBtn.textContent = "‚ùå";
        delBtn.onclick = () => {
          container.remove();
          saveConfigShortcuts();
          updatePreview();
        };
        container.appendChild(keyInput);
        container.appendChild(valInput);
        container.appendChild(delBtn);
        document.getElementById("configShortcutsList").appendChild(container);
        saveConfigShortcuts();
        if (!skipUpdate) updatePreview();
      }

      function saveConfigShortcuts() {
        configShortcuts = {};
        document
          .querySelectorAll("#configShortcutsList .config-shortcut")
          .forEach((c) => {
            const key = c.children[0].value.trim();
            const val = c.children[1].value.trim();
            if (key) configShortcuts[key] = val;
          });
      }

      /* ===========================
    Wildcard Shortcuts (WIP)
    =========================== */
      function addWildcard(key = "", value = "", skipUpdate = false) {
        const container = document.createElement("div");
        container.className = "wildcard-shortcut";

        const keyInput = document.createElement("input");
        keyInput.placeholder = "shortcut (e.g. $sky)"; // Using '$' prefix for wildcards
        keyInput.value = key;
        keyInput.oninput = () => {
          saveWildcardShortcuts();
          updatePreview();
        };

        const valInput = document.createElement("textarea");
        valInput.placeholder = "value options (e.g. blue sky|dawn|sunset)"; // Placeholder for typical wildcard values
        valInput.value = value;
        valInput.oninput = () => {
          saveWildcardShortcuts();
          updatePreview();
        };

        const delBtn = document.createElement("button");
        delBtn.textContent = "‚ùå";
        delBtn.onclick = () => {
          container.remove();
          saveWildcardShortcuts();
          updatePreview();
        };

        container.appendChild(keyInput);
        container.appendChild(valInput);
        container.appendChild(delBtn);

        // FIX: Changed ID from "wildcardShortcutsList" to the correct "wildcardsList"
        document.getElementById("wildcardsList").appendChild(container);

        saveWildcardShortcuts();

        if (!skipUpdate) updatePreview();
      }

      function saveWildcardShortcuts() {
        wildcardShortcuts = {}; // <-- Uses the new global variable
        // FIX: Changed selector from "#wildcardShortcutsList" to the correct "#wildcardsList"
        document
          .querySelectorAll("#wildcardsList .wildcard-shortcut")
          .forEach((c) => {
            const key = c.children[0].value.trim();
            const val = c.children[1].value.trim();
            if (key) wildcardShortcuts[key] = val;
          });
      }

      /* ===========================
       poseJSON Shortcuts (WIP)
       =========================== */
      // Renamed function to match HTML click handler: addPose()
      function addPose(key = "", value = "", skipUpdate = false) {
        const container = document.createElement("div");
        container.className = "poseJSON-shortcut";
        const keyInput = document.createElement("input");
        keyInput.placeholder = "shortcut (e.g. #armsup)";
        keyInput.value = key;
        keyInput.oninput = () => {
          saveposeJSONShortcuts();
          updatePreview();
        };
        const valInput = document.createElement("textarea");
        valInput.placeholder = "paste a full JSON Pose {...}";
        valInput.value = value;
        valInput.oninput = () => {
          saveposeJSONShortcuts();
          updatePreview();
        };
        const delBtn = document.createElement("button");
        delBtn.textContent = "‚ùå";
        // FIX: Updated reference to the correct function name
        delBtn.onclick = () => {
          container.remove();
          saveposeJSONShortcuts();
          updatePreview();
        };
        container.appendChild(keyInput);
        container.appendChild(valInput);
        container.appendChild(delBtn);
        document.getElementById("poseJSONShortcutsList").appendChild(container);
        saveposeJSONShortcuts();
        if (!skipUpdate) updatePreview();
      }

      function saveposeJSONShortcuts() {
        poseJSONShortcuts = {};
        document
          .querySelectorAll("#poseJSONShortcutsList .poseJSON-shortcut")
          .forEach((c) => {
            // FIX: Corrected selector ID
            const key = c.children[0].value.trim();
            const val = c.children[1].value.trim();
            if (key) poseJSONShortcuts[key] = val;
          });
      }

      // FIX: Added the iterative resolution logic, same as configShortcuts
      function resolveposeJSONShortcuts(text) {
        if (!text) return "";
        let replaced = text;
        let prev;
        do {
          prev = replaced;
          for (const [key, val] of Object.entries(poseJSONShortcuts)) {
            replaced = replaced.split(key).join(val);
          }
        } while (replaced !== prev);
        return replaced;
      }

      /* ===========================
           Create item DOM
           =========================== */
      function createItemElement(
        itemObj = { type: "prompt", value: "" },
        skipUpdate = false
      ) {
        const container = document.createElement("div");
        container.className = "item";
        container.draggable = false;
        container.dataset.type = itemObj.type;
        const dragHandle = document.createElement("div");
        dragHandle.className = "drag-handle";
        dragHandle.textContent = "‚ãÆ‚ãÆ";
        dragHandle.draggable = true; // KEEP for desktop mouse drag

        // === ADD TOUCH LISTENERS FOR IOS/MOBILE ===
        dragHandle.addEventListener("touchstart", handleTouchStart);
        dragHandle.addEventListener("touchmove", handleTouchMove);
        dragHandle.addEventListener("touchend", handleTouchEnd);
        // ==========================================

        dragHandle.addEventListener("dragstart", (e) => {
          draggedEl = container;
          container.classList.add("dragging");
          try {
            e.dataTransfer.setData("text/plain", "");
          } catch {}
          e.dataTransfer.effectAllowed = "move";
        });
        dragHandle.addEventListener("dragend", (e) => {
          document
            .getElementById("promptList")
            .classList.remove("dragging-active");
          if (draggedEl) {
            draggedEl.classList.remove("dragging");
            draggedEl = null;
          }
          removeDropIndicator();
        });
        container.appendChild(dragHandle);

        // create the number element
        const indexSpan = document.createElement("span");
        indexSpan.className = "item-index";
        container.appendChild(indexSpan);

        // Label
        const typeLabel = document.createElement("div");
        typeLabel.className = "item-type-label";
        typeLabel.textContent = formatTypeLabel(itemObj.type);
        container.appendChild(typeLabel);

        // Body depending on type
        if (
          itemObj.type === "prompt" ||
          itemObj.type === "config" ||
          itemObj.type === "note" ||
          itemObj.type === "negPrompt"
        ) {
          const ta = document.createElement("textarea");
          if (itemObj.type === "prompt") {
            ta.placeholder =
              "Prompt will generate \nAdd triggers and wildcards: @hero at $location \nDo not use quotes they will break Pipeline instructions";
          } else if (itemObj.type === "negPrompt") {
            ta.placeholder = "Add a negative prompt";
          } else if (itemObj.type === "note") {
            ta.placeholder =
              "Comment or instruction \nincluded in Export but ignored by Pipeline \nDo not use quotes they will break the instructions";
          } else {
            ta.placeholder =
              "Paste a full or parameter config {...} \nor use a single shortcut #wan_i2v or #16:9";
          }
          ta.value = itemObj.value || "";
          ta.addEventListener("input", () => updatePreview());
          container.appendChild(ta);
          container.dataset.valueType = "string";
        } else if (
          itemObj.type === "moveScale" ||
          itemObj.type === "adaptSize" ||
          itemObj.type === "moodboardWeights" ||
          itemObj.type === "maskBody" ||
          itemObj.type === "inpaintTools" ||
          itemObj.type === "xlMagic" ||
          itemObj.type === "loop" ||
          itemObj.type === "poseJSON"
        ) {
          const input = document.createElement("input");
          input.type = "text";
          input.value = itemObj.value || "";
          input.addEventListener("input", () => updatePreview());
          container.appendChild(input);
          container.dataset.valueType = "string";
          if (itemObj.type === "poseJSON") {
            input.placeholder =
              "Paste a full JSON Pose {...} or JSON Poses #shortcut";
          }
        } else if (itemObj.type === "maskAsk" || itemObj.type === "askZoom") {
          const el = document.createElement("div");
          el.style.flexGrow = "1";

          const prefix = document.createElement("span");
          prefix.textContent = "find object: ";
          el.appendChild(prefix);

          const input = document.createElement("input");
          input.type = "text";
          input.placeholder = "a hat";
          input.value = itemObj.value || "";
          input.addEventListener("input", () => updatePreview());

          el.appendChild(input);
          el.dataset.valueType = "string";

          container.appendChild(el);
        } else if (
          itemObj.type === "canvasSave" ||
          itemObj.type === "canvasLoad" ||
          itemObj.type === "moodboardAdd" ||
          itemObj.type === "loopAddMB" ||
          itemObj.type === "maskLoad" ||
          itemObj.type === "loopLoad" ||
          itemObj.type === "loopSave"
        ) {
          const el = document.createElement("div");
          el.style.flexGrow = "1"; // Maintain layout consistency

          const prefix = document.createElement("span");
          prefix.textContent = "~Pictures/";
          el.appendChild(prefix);

          const input = document.createElement("input");
          input.type = "text";
          input.placeholder =
            itemObj.type === "loopLoad" || itemObj.type === "loopAddMB"
              ? "myProject/batchFolder/"
              : "myProject/image.png";
          input.value = itemObj.value || "";
          input.addEventListener("input", () => updatePreview());

          el.appendChild(input);
          el.dataset.valueType = "string"; // Move dataset to wrapper

          container.appendChild(el); // Append the wrapper to the main container
        } else if (itemObj.type === "canvasClear") {
          const el = document.createElement("div");
          el.textContent = "Clear the Canvas and control layers";
          el.className = "small-muted";
          el.style.flexGrow = "1";
          container.appendChild(el);
          container.dataset.valueType = "boolean";
        } else if (
          itemObj.type === "moodboardClear" ||
          itemObj.type === "moodboardCanvas" ||
          itemObj.type === "moodboardLoad"
        ) {
          const el = document.createElement("div");
          el.textContent =
            itemObj.type === "moodboardClear"
              ? "Clear the full Moodboard"
              : "Copy the visible Canvas to Moodboard";
          el.className = "small-muted";
          el.style.flexGrow = "1";
          container.appendChild(el);
          container.dataset.valueType = "boolean";
        } else if (itemObj.type === "removeBkgd") {
          const el = document.createElement("div");
          el.textContent = "Make the background transparent / flat grey";
          el.className = "small-muted";
          el.style.flexGrow = "1";
          container.appendChild(el);
          container.dataset.valueType = "boolean";
        } else if (itemObj.type === "crop") {
          const el = document.createElement("div");
          el.textContent = "Crop the image to the visible canvas";
          el.className = "small-muted";
          el.style.flexGrow = "1";
          container.appendChild(el);
          container.dataset.valueType = "boolean";
        } else if (itemObj.type === "faceZoom") {
          const el = document.createElement("div");
          el.textContent = "Attempt face detection and scale in, no crop";
          el.className = "small-muted";
          el.style.flexGrow = "1";
          container.appendChild(el);
          container.dataset.valueType = "boolean";
        } else if (itemObj.type === "maskGet") {
          const el = document.createElement("div");
          el.textContent = "Copy the selection mask to Canvas";
          el.className = "small-muted";
          el.style.flexGrow = "1";
          container.appendChild(el);
          container.dataset.valueType = "boolean";
        } else if (
          itemObj.type === "maskClear" ||
          itemObj.type === "maskBkgd" ||
          itemObj.type === "maskFG"
        ) {
          const el = document.createElement("div");
          el.textContent =
            itemObj.type === "maskClear"
              ? "Clear the selection mask"
              : "Apply a selection mask";
          el.className = "small-muted";
          el.style.flexGrow = "1";
          container.appendChild(el);
          container.dataset.valueType = "boolean";
        } else if (
          itemObj.type === "depthToCanvas" ||
          itemObj.type === "depthCanvas"
        ) {
          const el = document.createElement("div");
          el.textContent = "Move a depthMap, does not extract";
          el.className = "small-muted";
          el.style.flexGrow = "1";
          container.appendChild(el);
          container.dataset.valueType = "boolean";
        } else if (itemObj.type === "depthExtract") {
          const el = document.createElement("div");
          el.textContent = "Extract a depthMap from Canvas to the depth layer";
          el.className = "small-muted";
          el.style.flexGrow = "1";
          container.appendChild(el);
          container.dataset.valueType = "boolean";
        } else if (itemObj.type === "fileLoad") {
          // Outer div for flex layout compatibility
          const el = document.createElement("div");
          el.style.flexGrow = "1";
          el.style.display = "flex"; // Ensure content inside also flexes
          el.style.alignItems = "center"; // Vertical alignment for better looks

          const prefix = document.createElement("span");
          prefix.textContent = "Include Instructions from: ";
          el.appendChild(prefix);

          // Hidden file input element
          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.accept = ".txt"; // Limit selection to .txt files
          fileInput.style.display = "none"; // Hide the default file input

          // Custom button/display element
          const displayButton = document.createElement("span");
          // Use the stored value (the file name) or a default prompt
          displayButton.textContent =
            itemObj.value || "Click to select .txt file";
          displayButton.style.cursor = "pointer";
          displayButton.style.textDecoration = "underline";
          displayButton.style.color = "#007bff"; // A nice blue link color
          displayButton.style.marginLeft = "5px";

          // Initialize the stored file content from a previous session if available
          // You'll need to modify your save/load logic to persist this content if needed,
          // but for now, we set the internal data attribute based on the value in case of DOM restoration.
          // NOTE: Due to browser security, you cannot restore the actual file content on page load,
          // only the file name (itemObj.value) is restorable. The user will have to select the file again.
          container.dataset.fileContent = "";

          // Handle file selection
          fileInput.addEventListener("change", (event) => {
            const file = event.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (e) => {
                // Store the file content on the container element
                container.dataset.fileContent = e.target.result;
                // Update the display to show the file name
                displayButton.textContent = file.name;
                // Update the itemObj.value so it saves/restores the file name
                // You'll need to link this back to your itemObj update logic

                // Assuming you have a standard way to update the underlying data object based on the DOM:
                // If not, you may need a separate function call here to save the new file name (file.name)

                // For demonstration, let's assume a function exists to update the data model:
                // updateItemValue(container, file.name);

                // For the immediate DOM display update:
                container.dataset.value = file.name;

                updatePreview(); // Trigger preview update
              };
              reader.readAsText(file); // Read the file as text
            }
          });

          // Handle click on the custom display to open the file picker
          displayButton.addEventListener("click", () => {
            fileInput.click();
          });

          el.appendChild(displayButton);
          el.appendChild(fileInput); // Keep the hidden input in the DOM
          container.appendChild(el);
          container.dataset.valueType = "fileContent"; // Flag for export function
        } else if (itemObj.type === "loopEnd") {
          const el = document.createElement("div");
          el.textContent = "Close the loop";
          el.className = "small-muted";
          el.style.flexGrow = "1";
          container.appendChild(el);
          container.dataset.valueType = "boolean";
        } else if (itemObj.type === "moodboardRemove") {
          const el = document.createElement("div");
          el.style.flexGrow = "1";
          const label = document.createElement("span");
          label.textContent = "at index: ";
          el.appendChild(label);
          const input = document.createElement("input");
          input.type = "number";
          input.min = "0";
          input.max = "11";
          input.value =
            itemObj.value !== undefined ? String(itemObj.value) : "";
          input.style.width = "40px";
          input.addEventListener("input", () => updatePreview());
          el.appendChild(input);
          el.dataset.valueType = "number";
          container.appendChild(el);
        } else if (itemObj.type === "frames") {
          const wrapper = document.createElement("div");
          wrapper.style.display = "flex";
          wrapper.style.alignItems = "center";
          wrapper.style.gap = "10px";
          wrapper.style.width = "100%";
          const slider = document.createElement("input");
          slider.type = "range";
          slider.min = 0;
          slider.max = 129;
          slider.step = 4;
          let sliderPos = 0;
          if (typeof itemObj.value === "number") {
            sliderPos = Number(itemObj.value) - 1;
            sliderPos = Math.round(sliderPos / 4) * 4;
            if (sliderPos < 0) sliderPos = 0;
            if (sliderPos > 129) sliderPos = 129;
          } else {
            sliderPos = 0;
          }
          slider.value = sliderPos;
          const valueBadge = document.createElement("div");
          valueBadge.className = "value-badge";
          valueBadge.textContent = (Number(slider.value) + 1).toString();
          const secondsBadge = document.createElement("span");
          secondsBadge.className = "small-muted";
          secondsBadge.textContent = `${(Number(slider.value) / 16).toFixed(
            2
          )} sec (16fps)`;
          slider.addEventListener("input", () => {
            valueBadge.textContent = (Number(slider.value) + 1).toString();
            secondsBadge.textContent = `${(Number(slider.value) / 16).toFixed(
              2
            )} sec (16fps)`;
            updatePreview();
          });
          wrapper.appendChild(slider);
          wrapper.appendChild(valueBadge);
          wrapper.appendChild(secondsBadge);
          container.appendChild(wrapper);
          container.dataset.valueType = "number";
        } else {
          const input = document.createElement("input");
          input.type = "text";
          input.value = itemObj.value || "";
          input.addEventListener("input", () => updatePreview());
          container.appendChild(input);
          container.dataset.valueType = "string";
        }
        const delBtn = document.createElement("button");
        delBtn.textContent = "‚ùå";
        delBtn.title = "Remove item";
        delBtn.onclick = () => {
          container.remove();
          updatePreview();
        };
        container.appendChild(delBtn);
        return container;
      }

      /* ===========================
    Read items from DOM
    =========================== */
      function readItemsFromDOM() {
        const list = document.getElementById("promptList");
        const items = [];
        list.querySelectorAll(".item").forEach((el) => {
          const type = el.dataset.type;
          let value;
          if (
            type === "prompt" ||
            type === "negPrompt" ||
            type === "config" ||
            type === "note"
          ) {
            const ta = el.querySelector("textarea");
            value = ta ? ta.value : "";
          } else if (
            type === "canvasSave" ||
            type === "canvasLoad" ||
            type === "moodboardAdd" ||
            type === "loopAddMB" ||
            type === "moodboardWeights" ||
            type === "maskLoad" ||
            type === "maskAsk" ||
            type === "askZoom" ||
            type === "maskBody" ||
            type === "inpaintTools" ||
            type === "depthCanvas" ||
            type === "moveScale" ||
            type === "adaptSize" ||
            type === "xlMagic" ||
            type === "loop" ||
            type === "loopLoad" ||
            type === "loopSave" ||
            type === "poseJSON" ||
            type === "fileLoad"
          ) {
            // Since 'fileLoad' doesn't use a visible text input for its value,
            // we need to check if the item is a standard text input or the custom file picker.
            if (type === "fileLoad") {
              // Retrieve the value (the file name) from a data attribute if available
              value = el.dataset.value || "";
            } else {
              // Existing logic for standard text inputs
              const input = el.querySelector("input[type='text']");
              value = input ? input.value : "";
            }
          } else if (type === "moodboardRemove") {
            const input = el.querySelector("input[type='number']");
            value = input ? parseInt(input.value, 10) : 1;
          } else if (type === "frames") {
            const slider = el.querySelector("input[type='range']");
            value = slider ? parseInt(slider.value, 10) + 1 : 1;
          } else {
            value = true;
          }
          items.push({ type, value });
        });
        return items;
      }

      /* ===========================
           Add item (to DOM)
           =========================== */
      function addItem(type = "prompt", value = undefined, skipUpdate = false) {
        const defaultValues = {
          note: "",
          prompt: "",
          config: "",
          frames: 1,
          askZoom: "",
          negPrompt: "",
          moveScale: `{"position_X": 512, "position_Y": 512, "canvas_scale": 1.8}`,
          adaptSize: `{"maxWidth": 1664, "maxHeight": 1664}`,
          moodboardAdd: "",
          loopAddMB: "",
          moodboardRemove: "0",
          moodboardWeights: `{"index_0": 1, "index_1": 0, "index_2": 0}`,
          xlMagic: `{"original": 3, "target": 4, "negative":7}`,
          canvasSave: "",
          canvasLoad: "",
          maskLoad: "",
          maskBody: `{"upper": true, "lower": true, "clothes": true, "neck": false, "extra": 5}`,
          maskAsk: "",
          inpaintTools: `{"strength": 1, "maskBlur": 0, "maskBlurOutset": 0, "preserveOriginalAfterInpaint": true}`,
          loop: `{"loop": 4, "start": 1}`,
          loopLoad: "",
          loopSave: "",
          poseJSON: "",
          pipeline: "",
          fileLoad: "",
        };
        const itemObj = {
          type,
          value: value === undefined ? defaultValues[type] : value,
        };
        const el = createItemElement(itemObj, skipUpdate);
        document.getElementById("promptList").appendChild(el);
        if (!skipUpdate) updatePreview();
        return el;
      }

      /* ===========================
   Drag & Drop helpers
   =========================== */
      function getDragAfterElement(container, y) {
        const els = [...container.querySelectorAll(".item:not(.dragging)")];
        let closest = { offset: Number.NEGATIVE_INFINITY, element: null };
        for (const child of els) {
          const box = child.getBoundingClientRect();
          const offset = y - (box.top + box.height / 2);
          if (offset < 0 && offset > closest.offset)
            closest = { offset, element: child };
        }
        return closest.element;
      }

      function removeDropIndicator() {
        if (dropIndicator.parentNode)
          dropIndicator.parentNode.removeChild(dropIndicator);
      }

      /* ===========================
   New Item Drag Start 
=========================== */
      function handleNewItemDragStart(e, type) {
        document.getElementById("promptList").classList.add("dragging-active");
        // 1. Store the item type in the dataTransfer object using a unique prefix
        e.dataTransfer.setData("text/plain", "NEW_ITEM:" + type);

        // 2. Set the drag operation type
        e.dataTransfer.effectAllowed = "copy";

        // 3. IMPORTANT: Reset the global draggedEl variable.
        // This tells the drop handler that it's an insertion, not a re-order.
        draggedEl = null;

        // Optional: Hide the drop indicator initially, as the dragover listener will place it.
        removeDropIndicator();
      }

      /* ===========================
   Mobile Touch Handlers for Drag & Drop (iOS FIX)
   =========================== */
      let touchY = 0;

      function handleTouchStart(e) {
        if (e.touches.length !== 1) return; // Only process single-touch events

        // 1. Find the item container (parent of the drag handle)
        draggedEl = e.currentTarget.closest(".item");
        if (!draggedEl) return;

        // 2. Prevent the default browser action (page scroll/move)
        e.preventDefault();

        // 3. Set the item state
        draggedEl.classList.add("dragging");

        // 4. Record the initial Y position
        touchY = e.touches[0].clientY;
      }

      function handleTouchMove(e) {
        if (!draggedEl || e.touches.length !== 1) return;

        // 1. Prevent page scrolling while dragging
        e.preventDefault();

        const currentY = e.touches[0].clientY;
        const list = document.getElementById("promptList");

        // 2. Determine where to drop the element (using the global helper)
        const after = getDragAfterElement(list, currentY);

        // 3. Move the drop indicator
        if (after == null) list.appendChild(dropIndicator);
        else list.insertBefore(dropIndicator, after);
      }

      function handleTouchEnd(e) {
        if (!draggedEl) return;

        // 1. Perform the final drop/reorder
        if (dropIndicator.parentNode) {
          dropIndicator.parentNode.insertBefore(draggedEl, dropIndicator);
        }

        // 2. Clean up state
        removeDropIndicator();
        draggedEl.classList.remove("dragging");
        draggedEl = null;

        // 3. Update the data
        updatePreview();
      }

      /* ===========================
   Existing Item Drag Start (Reorder)
   =========================== */
      function handleDragStart(e) {
        // *** FIX: Add class to enable CSS fix for dragover over text inputs ***
        document.getElementById("promptList").classList.add("dragging-active");

        draggedEl = e.target.closest(".item");
        e.dataTransfer.effectAllowed = "move";
        // The drag image will be set by the browser automatically
      }

      /* ===========================
   Drag & Drop (Desktop D&D API)
   =========================== */
      (function initItemDnD() {
        const list = document.getElementById("promptList");
        // Standard Desktop Mouse Drag Listeners
        list.addEventListener("dragover", (e) => {
          e.preventDefault();

          // Check if the current target of the event is the promptList itself
          // or if it's an element *within* a prompt item.

          // We want the insertion logic to run ONLY if we are dragging over the list area.
          if (e.target.closest("#promptList")) {
            // Use the existing helper to find the item before or after the drop position
            const afterElement = getDragAfterElement(list, e.clientY);

            // This is where you insert the visual drop indicator (a dashed line)
            if (afterElement == null) {
              // Drop at the end of the list
              list.appendChild(dropIndicator);
            } else {
              // Drop before the found element
              list.insertBefore(dropIndicator, afterElement);
            }
          }
        });
        list.addEventListener("drop", (e) => {
          e.preventDefault();

          // --- 1. Check if it's an INSERTION from the instruction bar ---
          const data = e.dataTransfer.getData("text/plain");
          if (data.startsWith("NEW_ITEM:")) {
            const type = data.substring("NEW_ITEM:".length);

            // Re-use the drag-over logic to find the drop target
            const after = getDragAfterElement(list, e.clientY);

            // Create the new item (reusing your existing creation logic)
            // NOTE: We pass 'true' to skip the updatePreview() call inside addItem.
            // We call it once at the end.
            const newEl = addItem(type, undefined, true);

            // Insert the new item before the drop indicator's current position
            if (after == null) {
              list.appendChild(newEl); // Drop at the very end
            } else {
              list.insertBefore(newEl, after); // Drop before 'after' element
            }

            removeDropIndicator();
            document
              .getElementById("promptList")
              .classList.remove("dragging-active");
            updatePreview(); // Final single update
            return; // Stop the drop function
          }

          // --- 2. EXISTING LOGIC: If it was NOT a new item, proceed with RE-ORDERING ---
          if (!draggedEl) return;

          if (dropIndicator.parentNode) {
            dropIndicator.parentNode.insertBefore(draggedEl, dropIndicator);
          }
          removeDropIndicator();
          draggedEl.classList.remove("dragging");
          draggedEl = null;
          document
            .getElementById("promptList")
            .classList.remove("dragging-active");
          updatePreview();
        });
        list.addEventListener("dragleave", (e) => {
          if (!list.contains(e.relatedTarget)) removeDropIndicator();
        });
        list.addEventListener("dragend", (e) => {
          // *** FIX: Remove class to re-enable text inputs after drag finishes (even if canceled) ***
          document
            .getElementById("promptList")
            .classList.remove("dragging-active");

          if (draggedEl) {
            draggedEl.classList.remove("dragging");
          }
          removeDropIndicator();
          draggedEl = null;
        });
      })();

      /* ===========================
           Tabbed Interface
           =========================== */
      function openTab(evt, tabId) {
        // Get all elements with class="tab-panel" and hide them
        const tabPanels = document.querySelectorAll(".tab-panel");
        tabPanels.forEach((panel) => {
          panel.style.display = "none";
          panel.classList.remove("active");
        });

        // Get all elements with class="tab-button" and remove the "active" class
        const tabButtons = document.querySelectorAll(".tab-button");
        tabButtons.forEach((button) => {
          button.classList.remove("active");
        });

        // Show the current tab, and add an "active" class to the button and panel
        const activePanel = document.getElementById(tabId);
        if (activePanel) {
          activePanel.style.display = "block";
          activePanel.classList.add("active");
        }
        evt.currentTarget.classList.add("active");
      }

      /* ===========================
           Trigger resolution
           =========================== */
      function resolvePromptTriggers(text) {
        if (!text) return "";
        let replaced = text;
        let prev;
        do {
          prev = replaced;
          for (const [key, val] of Object.entries(promptTriggers)) {
            replaced = replaced.split(key).join(val);
          }
        } while (replaced !== prev);
        return replaced;
      }

      function resolveConfigShortcuts(text) {
        if (!text) return "";
        let replaced = text;
        let prev;
        do {
          prev = replaced;
          for (const [key, val] of Object.entries(configShortcuts)) {
            replaced = replaced.split(key).join(val);
          }
        } while (replaced !== prev);
        return replaced;
      }

      function resolveWildcardShortcuts(text) {
        if (!text) return "";
        let replaced = text;

        // Pattern to find wildcards: $key or $key[N]
        // Group 1: $key (e.g., $sky)
        // Group 2 (optional): [N] (e.g., [2])
        const wildcardPattern = /(\$[a-zA-Z0-9_]+)(\[\d+\])?/g;

        // Use a loop to replace all occurrences until no more are found
        // This is similar to your existing resolution loops.
        let prev;
        do {
          prev = replaced;
          replaced = replaced.replace(
            wildcardPattern,
            (match, key, indexGroup) => {
              // key is the full trigger, e.g., "$sky"
              const valueString = wildcardShortcuts[key];

              // If the key is not defined, return the original match (e.g., "$unknown")
              if (!valueString) {
                return match;
              }

              // Split the pipe-delimited string into an array of options
              const options = valueString
                .split("|")
                .map((s) => s.trim())
                .filter((s) => s.length > 0);

              if (options.length === 0) {
                return match; // No options defined
              }

              let replacementValue;

              if (indexGroup) {
                // Case B: Specific index requested ($key[N])
                // 1. Remove brackets to get the number string, 2. Convert to integer, 3. Adjust for 0-based array
                const requestedIndex =
                  parseInt(indexGroup.slice(1, -1), 10) - 1;

                // Ensure index is valid
                replacementValue =
                  requestedIndex >= 0 && requestedIndex < options.length
                    ? options[requestedIndex]
                    : match; // If index is invalid, return the original wildcard
              } else {
                // Case A: Random selection requested ($key)
                const randomIndex = Math.floor(Math.random() * options.length);
                replacementValue = options[randomIndex];
              }

              return replacementValue;
            }
          );
        } while (replaced !== prev);

        return replaced;
      }

      /* ===========================
    Update Item Numbers
    =========================== */
      function updateItemNumbers() {
        const items = document.querySelectorAll("#promptList .item");
        items.forEach((item, index) => {
          const itemNumber = index + 1;

          // 1. Update the visible index number (your existing logic)
          const indexSpan = item.querySelector(".item-index");
          if (indexSpan) {
            indexSpan.textContent = `${itemNumber}.`;
          }

          // 2. Add or update the data-index attribute on the main container
          // This is what allows updatePreview() to correctly find the element later.
          item.dataset.index = itemNumber;
        });
      }

      /* ===========================
    Preview
    =========================== */
      function updatePreview() {
        updateItemNumbers();
        savePromptTriggers();
        const projectName =
          document.getElementById("projectName").value || "Unnamed";
        const items = readItemsFromDOM();
        let promptCount = 0;
        let framesCount = 0;
        let framesTotal = 0;

        // --- Step 1: Count calculations ---
        items.forEach((item) => {
          if (item.type === "prompt") {
            promptCount++;
          } else if (item.type === "frames" && item.value > 1) {
            framesCount++;
            framesTotal += item.value - framesCount;
          }
        });

        // --- Step 2: Output Header ---
        let output = `=== PROJECT: ${projectName} ===\n\n`;
        output += `Prompt Total: ${promptCount}\n`;
        output += `Frames Total: ${framesTotal} (${(
          Number(framesTotal) / 16
        ).toFixed(2)} sec 16fps)\n\n`;
        output += "=== Instructions (expanded prompts) ===\n";

        // --- Step 3: Instruction Compilation ---
        items.forEach((it, idx) => {
          const itemElement = document.querySelector(
            `.item[data-type="${it.type}"][data-index="${idx + 1}"]`
          );

          // ======================================
          // ‚ú® NEW LOGIC FOR FILELOAD ITEM ‚ú®
          // ======================================
          if (it.type === "fileLoad") {
            const itemElement = document.querySelector(
              `.item[data-type="${it.type}"][data-index="${idx + 1}"]`
            );
            const container = itemElement;
            const fileContent = container ? container.dataset.fileContent : "";
            const fileName = it.value; // The saved file name

            output += `[${idx + 1}] ${it.type}: **${
              fileName || "Please reselect pipeline txt"
            }**\n`;

            if (fileContent) {
              // Split, trim, and filter lines
              const lines = fileContent
                .trim()
                .split("\n")
                .filter((line) => line.trim() !== "");

              let linesToDisplay = lines;
              if (lines.length > 0) {
                const lastLine = lines[lines.length - 1].trim().toLowerCase();
                // Correctly identify and remove the final 'end' line for display
                if (lastLine.startsWith("end:")) {
                  linesToDisplay = lines.slice(0, -1);
                }
              }

              output += `--- INCLUDED CONTENT START ---\n`;

              // Format each line for cleaner display
              linesToDisplay.forEach((line) => {
                let formattedLine = line.trim();

                // Optional: Attempt to clean up JSON-like object strings for display
                // If your keys/values are always simple key:value or key:{...}
                const parts = formattedLine
                  .split(/:(.*)/s)
                  .map((s) => s.trim());
                if (parts.length === 3) {
                  const key = parts[0];
                  let value = parts[1];

                  // Remove surrounding quotes from values that are simple JSON strings
                  if (value.startsWith('"') && value.endsWith('"')) {
                    value = value.slice(1, -1);
                  }

                  // If the value is a complex object/array, format it nicely (optional)
                  try {
                    const obj = JSON.parse(value);
                    value = JSON.stringify(obj, null, 2).replace(
                      /\n/g,
                      "\n    "
                    ); // Pretty print with indent
                    formattedLine = `${key}: ${value}`;
                  } catch (e) {
                    formattedLine = `${key}: ${value}`;
                  }
                }

                output += `${formattedLine}\n`;
              });

              output += `--- INCLUDED CONTENT END ---\n\n`;
            } else if (fileName) {
              // CRITICAL REMINDER TO USER
              output += `\nüö® **WARNING**: File content for '${fileName}' is NOT currently loaded.\n`;
              output += `    Please re-select the file using the file picker above to include instructions in the final export.\n\n`;
            } else {
              output += `\n(No file selected, will be skipped in export)\n\n`;
            }
            // ======================================
            // End of NEW LOGIC
            // ======================================
          } else if (it.type === "prompt") {
            const expanded = resolvePromptTriggers(it.value || "");
            output += `[${idx + 1}] ${it.type}: "${expanded}"\n\n`;
          } else if (it.type === "negPrompt") {
            output += `[${idx + 1}] ${it.type}: "${it.value}"\n\n`;
          } else if (
            it.type === "note" ||
            it.type === "config" ||
            it.type === "poseJSON"
          ) {
            output += `[${idx + 1}] ${it.type}: ${it.value}\n\n`;
          } else if (
            it.type === "canvasLoad" ||
            it.type === "canvasSave" ||
            it.type === "loopLoad" ||
            it.type === "loopSave" ||
            it.type === "moodboardAdd" ||
            it.type === "loopAddMB" ||
            it.type === "maskLoad" ||
            it.type === "maskAsk" ||
            it.type === "askZoom"
          ) {
            output += `[${idx + 1}] ${it.type}: ${JSON.stringify(
              it.value
            )}\n\n`;
          } else if (it.type === "frames") {
            output += `[${idx + 1}] ${it.type}: ${JSON.stringify(
              it.value
            )} ‚Äî ${JSON.stringify((it.value - 1) / 16)}sec (16fps)\n\n`;
          } else if (
            it.type === "moveScale" ||
            it.type === "adaptSize" ||
            it.type === "xlMagic" ||
            it.type === "loop" ||
            it.type === "moodboardRemove" ||
            it.type === "moodboardWeights" ||
            it.type === "maskBody" ||
            it.type === "inpaintTools" ||
            it.type === "pipeline" // Keeping 'pipeline' in case you want to rename it later
          ) {
            output += `[${idx + 1}] ${it.type}: ${it.value}\n\n`;
          } else {
            output += `[${idx + 1}] ${it.type}\n\n`;
          }
        });

        document.getElementById("preview").textContent = output;
      }

      /* ===========================
    Project Save/Load/Export
    =========================== */
      async function saveProject() {
        savePromptTriggers();
        saveConfigShortcuts();
        saveposeJSONShortcuts();
        
        // Check if function exists before calling
        if (typeof saveWildcardShortcuts === "function") {
            saveWildcardShortcuts();
        } else {
            console.warn("saveWildcardShortcuts is not a function");
        }

        const projectName =
          document.getElementById("projectName").value || "StoryFlowProject";
        
        const items = readItemsFromDOM();

        const data = {
          projectName,
          promptTriggers,
          configShortcuts,
          poseJSONShortcuts,
          wildcardShortcuts: (typeof wildcardShortcuts !== 'undefined') ? wildcardShortcuts : {},
          items,
        };

        const jsonStr = JSON.stringify(data, null, 2);

        if ("showSaveFilePicker" in window) {
          try {
            const handle = await window.showSaveFilePicker({
              suggestedName: projectName + ".json",
              types: [
                {
                  description: "JSON Files",
                  accept: { "application/json": [".json"] },
                },
              ],
            });
            const writable = await handle.createWritable();
            await writable.write(jsonStr);
            await writable.close();
          } catch (err) {
            console.error(err);
          }
        } else {
          const blob = new Blob([jsonStr], { type: "application/json" });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = projectName + ".json";
          a.click();
        }
      }

      /* ===========================
    Load Project -> read JSON and rebuild DOM
    =========================== */
      function loadProject() {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json";
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (evt) => {
            try {
              const data = JSON.parse(evt.target.result);
              // Clear current project
              document.getElementById("projectName").value = "";
              document.getElementById("triggerListPrompt").innerHTML = "";
              document.getElementById("configShortcutsList").innerHTML = "";
              document.getElementById("poseJSONShortcutsList").innerHTML = "";
              document.getElementById("wildcardsList").innerHTML = ""; // <-- NEW: Clear Wildcard DOM
              document.getElementById("promptList").innerHTML = "";
              promptTriggers = {};
              configShortcuts = {};
              poseJSONShortcuts = {};
              wildcardShortcuts = {}; // <-- NEW: Clear Wildcard state
              // Restore project name
              document.getElementById("projectName").value =
                data.projectName || "";
              // Restore prompt triggers
              if (
                data.promptTriggers &&
                typeof data.promptTriggers === "object"
              ) {
                Object.entries(data.promptTriggers).forEach(([k, v]) =>
                  addTriggerPrompt(k, v, true)
                );
              }
              // Restore config shortcuts
              if (
                data.configShortcuts &&
                typeof data.configShortcuts === "object"
              ) {
                Object.entries(data.configShortcuts).forEach(([k, v]) =>
                  addConfigShortcut(k, v, true)
                );
              }
              // Restore poseJSON shortcuts
              if (
                data.poseJSONShortcuts &&
                typeof data.poseJSONShortcuts === "object"
              ) {
                Object.entries(data.poseJSONShortcuts).forEach(([k, v]) =>
                  addPose(k, v, true)
                );
              }
              // Restore wildcard shortcuts
              if (
                data.wildcardShortcuts &&
                typeof data.wildcardShortcuts === "object"
              ) {
                // <-- NEW: Restore Wildcard shortcuts
                Object.entries(data.wildcardShortcuts).forEach(([k, v]) =>
                  addWildcard(k, v, true)
                );
              }
              // Restore items
              if (Array.isArray(data.items)) {
                data.items.forEach((it) => addItem(it.type, it.value, true));
              }
              // Refresh preview
              updatePreview();
            } catch (err) {
              console.error("Failed to load project:", err);
              alert("Invalid project file.");
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }

      /* ===========================
           New Project: clear DOM 
           =========================== */
      function newProject() {
        document.getElementById("projectName").value = "";
        document.getElementById("triggerListPrompt").innerHTML = "";
        document.getElementById("configShortcutsList").innerHTML = "";
        document.getElementById("poseJSONShortcutsList").innerHTML = "";
        document.getElementById("wildcardsList").innerHTML = ""; // <-- NEW: Clear Wildcard DOM
        document.getElementById("promptList").innerHTML = "";
        promptTriggers = {};
        configShortcuts = {};
        poseJSONShortcuts = {};
        wildcardShortcuts = {}; // <-- NEW: Clear Wildcard state
        addItem("prompt", "", true);
        updatePreview();
      }

      /* ===========================
    Generates the Instruction String
    =========================== */
      function generateInstructionString() {
        savePromptTriggers();
        saveConfigShortcuts();
        saveposeJSONShortcuts();
        saveWildcardShortcuts();
        const items = readItemsFromDOM();

        // Use an array to collect instructions (without trailing commas)
        const instructionArray = [];

        // --- 1. Iterate through DOM items and build instruction objects ---
        items.forEach((it, idx) => {
          let instructionString = "";

          // ======================================
          // ‚ú® REVISED LOGIC FOR FILELOAD ITEM ‚ú®
          // ======================================
          if (it.type === "fileLoad") {
            const itemElement = document.querySelector(
              `.item[data-type="${it.type}"][data-index="${idx + 1}"]`
            );
            const fileContent = itemElement
              ? itemElement.dataset.fileContent
              : "";

            if (fileContent) {
              // Split, trim, and filter the raw content
              const rawLines = fileContent.split("\n");

              const instructionsToInsert = rawLines
                .map((line) => line.trim()) // Remove leading/trailing whitespace
                .filter((line) => line.length > 0) // Remove empty lines
                .filter((line) => line !== "[" && line !== "]") // Remove standalone brackets
                .map((line) => {
                  // Crucial: Remove the trailing comma and newline/space to prepare for insertion
                  if (line.endsWith(",")) {
                    line = line.slice(0, -1).trim();
                  }
                  return line;
                })
                // Filter out the {"end": true} line
                .filter((line) => !line.startsWith('{"end":'));

              // Directly push the clean, comma-free instruction strings into the array
              instructionArray.push(...instructionsToInsert);
            }
            return;
          }
          // ======================================
          // END NEW LOGIC
          // ======================================

          // --- Existing Logic (same as before, but without the trailing comma/newline) ---
          if (it.type === "note") {
            instructionString = `{"${it.type}": ${JSON.stringify(it.value)}}`;
          } else if (it.type === "prompt" || it.type === "negPrompt") {
            // 1. Resolve Prompt Triggers first (@hero -> brave knight)
            const promptWithTriggers = resolvePromptTriggers(it.value || "");

            // 2. Resolve Wildcards from the result (brave knight $sky -> brave knight blue sky)
            const finalPrompt = resolveWildcardShortcuts(promptWithTriggers);

            instructionString = `{"${it.type}": ${JSON.stringify(
              finalPrompt
            )}}`;
          } else if (it.type === "config") {
            instructionString = `{"config": ${resolveConfigShortcuts(
              it.value || ""
            )}}`;
          } else if (it.type === "poseJSON") {
            instructionString = `{"poseJSON": ${resolveposeJSONShortcuts(
              it.value || ""
            )}}`;
          } else if (it.type === "frames" || it.type === "moodboardRemove") {
            instructionString = `{"${it.type}": ${it.value}}`;
          } else if (
            it.type === "moveScale" ||
            it.type === "adaptSize" ||
            it.type === "xlMagic" ||
            it.type === "loop" ||
            it.type === "moodboardWeights" ||
            it.type === "maskBody" ||
            it.type === "inpaintTools"
          ) {
            instructionString = `{"${it.type}": ${it.value}}`;
          } else if (
            it.type === "canvasSave" ||
            it.type === "canvasLoad" ||
            it.type === "pipeline" ||
            it.type === "loopLoad" ||
            it.type === "loopSave" ||
            it.type === "moodboardAdd" ||
            it.type === "loopAddMB" ||
            it.type === "maskLoad" ||
            it.type === "maskAsk" ||
            it.type === "askZoom"
          ) {
            instructionString = `{"${it.type}": ${JSON.stringify(it.value)}}`;
          } else {
            instructionString = `{"${it.type}": true}`;
          }

          // Add the clean instruction string to the array
          if (instructionString) {
            instructionArray.push(instructionString);
          }
        });

        // --- 2. Final Assembly ---

        // Add the mandatory 'end' instruction at the very end
        instructionArray.push(`{"end": true}`);

        // Join all instructions with a comma and newline, and wrap in brackets
        // This correctly places the comma delimiters between instructions and removes all trailing commas.
        const output = "[\n" + instructionArray.join(", \n") + "\n]";

        return output;
      }

      /* ===========================
           Export to Pipeline (.txt)
           =========================== */
      function exportTextfile() {
        const output = generateInstructionString();

        const blob = new Blob([output], { type: "text/plain" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = (projectName.value || "project") + ".txt";
        a.click();
      }

      /* ===========================
           Export to Clipboard
           =========================== */
      function exportClipboard() {
        const output = generateInstructionString();
        navigator.clipboard.writeText(output);
      }

      /* ===========================
       Wildcard Script Import/Export
       =========================== */
       function exportConfigPoseScript() {
        saveConfigShortcuts();
        saveposeJSONShortcuts();
        let output = "";

        // 1. Export Configs
        for (const [key, val] of Object.entries(configShortcuts)) {
          let defKey = key.startsWith("#") ? key : "#" + key;
          let content = val.trim();
          if (content.startsWith("{") && content.endsWith("}")) {
             output += `${defKey} := ${content}\n\n`;
          } else {
             output += `${defKey} := { ${content} }\n\n`;
          }
        }

        // 2. Export Poses
        for (const [key, val] of Object.entries(poseJSONShortcuts)) {
          let defKey = key.startsWith("#") ? key : "#" + key;
          let content = val.trim();
          if (content.startsWith("{") && content.endsWith("}")) {
             output += `${defKey} := ${content}\n\n`;
          } else {
             output += `${defKey} := { ${content} }\n\n`;
          }
        }

        if (output.trim() === "") {
            alert("No Configs or Poses to export.");
            return;
        }

        const blob = new Blob([output], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "config_poses.txt";
        a.click();
        URL.revokeObjectURL(url);
      }

      function importConfigPoseScript() {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".txt";
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (evt) => {
            const text = evt.target.result;
            try {
              // --- Helper: Extract balanced braces (handles nested {} and []) ---
              function extractBalancedBraces(str, start) {
                if (str[start] !== '{') return null;
                let curlyDepth = 0;
                let squareDepth = 0;
                for (let i = start; i < str.length; i++) {
                  const char = str[i];
                  if (char === '{') curlyDepth++;
                  else if (char === '}') {
                    curlyDepth--;
                    if (curlyDepth === 0 && squareDepth === 0) {
                      return { content: str.substring(start, i + 1), end: i };
                    }
                  }
                  else if (char === '[') squareDepth++;
                  else if (char === ']') squareDepth--;
                }
                return null;
              }

              // --- Parse Definitions (Configs/Poses Only) ---
              // Regex to find #name := { (start of definition)
              const defStartRegex = /#(\w+)\s*:=\s*\{/g;
              let match;
              let count = 0;

              while ((match = defStartRegex.exec(text)) !== null) {
                const name = match[1];
                const braceStart = match.index + match[0].length - 1; // Position of '{'
                const extracted = extractBalancedBraces(text, braceStart);
                
                if (extracted) {
                  let content = extracted.content;
                  
                  // Validate JSON
                  try {
                    JSON.parse(content);
                  } catch (jsonErr) {
                    console.warn(`Config #${name} is not valid JSON: ${jsonErr.message}`);
                    console.log(`  Content: ${content.substring(0, 100)}...`);
                  }
                  
                  // Heuristic for Config vs Pose
                  if (content.includes('"points"')) {
                     // Pose
                     addPose(`#${name}`, content);
                  } else {
                     // Config
                     addConfigShortcut(`#${name}`, content);
                  }
                  count++;
                  
                  // Move regex past this definition to avoid re-matching
                  defStartRegex.lastIndex = extracted.end + 1;
                }
              }
              
              // Don't fail on updatePromptPreview errors
              try {
                updatePromptPreview();
              } catch (previewErr) {
                console.warn("updatePromptPreview error (non-fatal):", previewErr);
              }
              
              if (count > 0) {
                alert(`Imported ${count} Configs/Poses.`);
              } else {
                alert("No configs/poses found in file. Make sure format is: #name := {...}");
              }

            } catch (err) {
              console.error("Failed to parse Config/Pose Script:", err);
              alert("Error parsing file: " + err.message);
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }

      function importWildcardScript() {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".txt";
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (evt) => {
            const text = evt.target.result;
            try {
              // Clear existing project
              newProject();

              // --- Parse Definitions ---
              // Regex to find @name, $name, or #name := { content }
              const defRegex = /([@$#])(\w+)\s*:=\s*\{([\s\S]*?)\}/g;
              let match;
              const definitions = {};

              while ((match = defRegex.exec(text)) !== null) {
                const prefix = match[1]; 
                const key = match[2].trim(); 
                const value = match[3].trim();

                if (prefix === '#') {
                    // Config or Pose
                    // Check if value needs brace restoration (if parser stripped them from a single-brace definition)
                    // Heuristic: If it looks like JSON properties but isn't wrapped in {}, try wrapping it.
                    if (!value.startsWith('{') && value.includes(':')) {
                         try {
                             JSON.parse('{' + value + '}');
                             value = '{' + value + '}';
                         } catch (e) {
                             // Not valid JSON body, leave as is
                         }
                    }

                    // Heuristic: If value contains "points", it's likely a JSON Pose
                    if (value.includes('"points"')) {
                        addPose(`#${key}`, value, true);
                    } else {
                        addConfigShortcut(`#${key}`, value, true);
                    }
                } else {
                    // Store @/$ for later Wildcard/Trigger processing
                    definitions[key] = value;
                }
              }

              // --- Parse PROMPT ---
              // Regex to find PROMPT: [ content ]
              const promptRegex = /PROMPT:\s*\[([\s\S]*?)\]/;
              const promptMatch = promptRegex.exec(text);

              if (promptMatch) {
                const fullPrompt = promptMatch[1].trim();

                let finalPrompt = fullPrompt;

                // --- Distribute Definitions ---
                Object.keys(definitions).forEach((key) => {
                  const val = definitions[key];
                  const isWildcard = val.includes("|");

                  if (isWildcard) {
                    // Rule: Multi-entry -> Wildcard ($key)
                    // Import as Wildcard
                    addWildcard(`$${key}`, val, true);
                    
                    // Update any @key usage in prompt to $key (normalization)
                    const regexAt = new RegExp(`@${key}\\b`, "g");
                    finalPrompt = finalPrompt.replace(regexAt, `$${key}`);
                  } else {
                    // Rule: Single-entry -> Prompt Trigger (@key)
                    // Import as Trigger
                    addTriggerPrompt(`@${key}`, val, true);
                    
                    // Update any $key usage in prompt to @key (normalization)
                    const regexDollar = new RegExp(`\\$${key}\\b`, "g");
                    finalPrompt = finalPrompt.replace(regexDollar, `@${key}`);
                  }
                });

                // --- Create Prompt Items ---
                // Split by pipe '|' and add prompts
                const promptParts = finalPrompt.split("|");
                promptParts.forEach((part) => {
                  const trimmed = part.trim();
                  if (trimmed) {
                    addItem("prompt", trimmed, true);
                  }
                });
              }

              updatePreview();
              // alert("Wildcard Script imported successfully!");
            } catch (err) {
              console.error("Failed to parse Wildcard Script:", err);
              alert("Error parsing file. Check console for details.");
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }

      function exportWildcardScript() {
        savePromptTriggers();
        saveWildcardShortcuts();
        saveConfigShortcuts();
        saveposeJSONShortcuts();
        let output = "";

        // 1. Export Configs & Poses (Header)
        for (const [key, val] of Object.entries(configShortcuts)) {
          let defKey = key.startsWith("#") ? key : "#" + key;
          let content = val.trim();
          // Avoid double-wrapping if the value already looks like a complete JSON object
          if (content.startsWith("{") && content.endsWith("}")) {
             output += `${defKey} := ${content}\n\n`;
          } else {
             output += `${defKey} := { ${content} }\n\n`;
          }
        }
        for (const [key, val] of Object.entries(poseJSONShortcuts)) {
          let defKey = key.startsWith("#") ? key : "#" + key;
          let content = val.trim();
          if (content.startsWith("{") && content.endsWith("}")) {
             output += `${defKey} := ${content}\n\n`;
          } else {
             output += `${defKey} := { ${content} }\n\n`;
          }
        }

        // 2. Export Prompt Triggers (@key := {val})
        for (const [key, val] of Object.entries(promptTriggers)) {
          let defKey = key.startsWith("@") ? key : "@" + key;
          output += `${defKey} := { ${val} }\n\n`;
        }

        // 2. Export Wildcards ($key -> @key := {val})
        for (const [key, val] of Object.entries(wildcardShortcuts)) {
          let defKey = key;
          if (key.startsWith("$")) {
            defKey = "@" + key.substring(1);
          } else if (!key.startsWith("@")) {
            defKey = "@" + key;
          }
          output += `${defKey} := { ${val} }\n\n`;
        }

        // 3. Export Items as PROMPT: [ ... ]
        // Note: We need to access readItemsFromDOM which might not be global,
        // but saveProject uses it so it should be available.
        // Checking file again: readItemsFromDOM is used in saveProject (line 1748) and generateInstructionString (1856).
        // It's not defined in the snippets I saw.
        // Logic check: if it was inside a closure (IIFE), saveProject wouldn't see it unless saveProject is also therein.
        // saveProject is global. So readItemsFromDOM must be global or available in the scope.

        const items = readItemsFromDOM();
        const promptValues = [];
        items.forEach((it) => {
          if (it.type === "prompt") {
            let content = it.value;
            // Convert Wildcards ($name) to Wildcards Plus format (@name) in the prompt
            // We iterate over known wildcard definitions to be safe
            for (const key of Object.keys(wildcardShortcuts)) {
              if (key.startsWith("$")) {
                  const bareName = key.substring(1);
                  // Replace $name with @name
                  const regex = new RegExp(`\\$${bareName}\\b`, 'g');
                  content = content.replace(regex, `@${bareName}`);
              }
            }
            promptValues.push(content);
          }
        });

        if (promptValues.length > 0) {
          output += `PROMPT: [ ${promptValues.join(" | ")} ]`;
        }

        const blob = new Blob([output], { type: "text/plain" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        const projectName =
          document.getElementById("projectName").value || "Project";
        a.download = projectName + "_wildcard.txt";
        a.click();
      }

      /* ===========================
       Boot defaults
       =========================== */
      function boot() {
        newProject();
        updatePreview();
      }

      /* ===========================
   Preview Toggle Function
   =========================== */
      function togglePreview() {
        const container = document.getElementById("previewContainer");
        const toggleButton = document.getElementById("previewToggle");
        const previewContent = document.getElementById("preview");

        if (previewContent.style.display === "none") {
          previewContent.style.display = "block";
          toggleButton.textContent = "Hide";
          container.dataset.open = "true";
        } else {
          previewContent.style.display = "none";
          toggleButton.textContent = "Show";
          container.dataset.open = "false";
        }
      }

      boot();
    </script>

    <div
      class="glasp-ui-wrapper"
      id="glasp-ui-wrapper"
      style="height: 0px; width: 0px; padding: 0px"
    >
      <iframe
        name="glasp-tooltip-iframe"
        id="glasp-tooltip-iframe"
        style="display: none"
        src="./Storyflow Editor for DrawThings_files/saved_resource.html"
      ></iframe
      ><iframe
        name="glasp-sidebar-iframe"
        id="glasp-sidebar-iframe"
        style="
          display: none !important;
          width: 0px !important;
          min-width: 0px !important;
          max-width: 320px;
          height: 100%;
          background: transparent;
          margin: auto;
          position: fixed;
          top: 0px;
          right: 0px;
          left: auto;
          z-index: 9000000000000000000;
          border: none !important;
        "
        src="./Storyflow Editor for DrawThings_files/saved_resource(1).html"
      ></iframe>
    </div>
    <a
      id="bottomBar"
      style="
        position: fixed;
        bottom: -40px;
        left: 0px;
        z-index: 9999;
        transform: translateX(-50%);
        background-color: transparent;
        border-radius: 5px 5px 0px 0px;
        opacity: 0.3;
        padding: 5px;
        transition: 0.3s;
        cursor: pointer;
        max-height: 100px;
        max-width: 45px;
      "
      ><img
        src="chrome-extension://kobncfkmjelbefaoohoblamnbackjggk/icon/icon_32.png"
        style="width: 32px; height: 32px"
    /></a>
    <div
      id="yt_article_summary_widget_wrapper"
      class="yt_article_summary_widget_wrapper"
      style="
        display: none;
        margin: auto;
        width: fit-content;
        padding: 0px;
        border-radius: 100%;
      "
    >
      <div id="yt_article_summary_widget" class="yt_article_summary_widget">
        <svg
          width="24"
          height="24"
          viewBox="0 0 48 48"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M1.40123 27.3686C-0.44103 25.5284 -0.441033 22.5449 1.4012 20.7047L16.5971 5.52573L24.0098 12.9301L5.47818 31.4409L1.40123 27.3686Z"
            fill="#FF4E74"
          ></path>
          <path
            d="M35.1286 24.0367L16.5972 5.5258L20.6741 1.45341C22.5164 -0.386772 25.5033 -0.386775 27.3455 1.45341L42.5415 16.6323L35.1286 24.0367Z"
            fill="#FFF85E"
          ></path>
          <path
            d="M24.0099 35.143L42.5416 16.6323L46.6183 20.7046C48.4606 22.5448 48.4606 25.5284 46.6183 27.3686L31.4224 42.5476L24.0099 35.143Z"
            fill="#76FF54"
          ></path>
          <path
            d="M27.3454 46.6198C25.5032 48.4601 22.5163 48.4601 20.674 46.6198L5.47815 31.4409L12.8908 24.0366L31.4223 42.5476L27.3454 46.6198Z"
            fill="#5C94FF"
          ></path>
        </svg>
      </div>
      <div
        id="yt_article_summary_close_button"
        class="yt_article_summary_close_button"
      >
        √ó
      </div>
    </div>
    <div
      id="glasp-extension-toast-container"
      style="
        position: fixed;
        top: 32px;
        right: 16px;
        z-index: 2147483647;
        display: none;
        flex-direction: column;
        align-items: flex-end;
        height: 0px;
        width: auto;
        margin: 0px;
        padding: 0px;
      "
    ></div>
  </body>
  <div
    id="iframe_container"
    style="
      position: fixed;
      top: 0px;
      right: 0px;
      width: 480px;
      height: 100%;
      z-index: 2147483647;
      transition: transform 0.5s ease-in-out;
      transform: translateX(480px);
      display: none;
    "
  >
    <div
      class="resizer"
      style="
        width: 10px;
        height: 100%;
        position: absolute;
        left: 0px;
        top: 0px;
        cursor: ew-resize;
      "
    >
      <div
        style="
          position: absolute;
          left: 0px;
          top: 0px;
          width: 2px;
          height: 100%;
          background: rgba(228, 228, 228, 0.5);
          cursor: ew-resize;
        "
      ></div>
    </div>
    <iframe
      id="iframe_root"
      style="width: 100%; height: 100%; margin: 0px 0px 0px 2px; border: 0px"
      src="./Storyflow Editor for DrawThings_files/saved_resource(2).html"
    ></iframe>
  </div>
</html>
